<template>
  <div class="wiki">
    <h2>
      Модули
      <gtag type="hard">Программистам</gtag>
    </h2>
    <p>Этот раздел посвящен разработке модулей на Java</p>
    <p>
      Загрузка модулей происходит из папки modules. Менеджер модулей открывает
      по очереди все jar и смотрит на параметр Module-Main-Class в манифесте JAR
      файла.
    </p>
    <p>
      Класс модуля - это класс, наследуемый от
      <b>pro.gravit.launcher.modules.LauncherModule</b> и реализующий метод
      init(LauncherInitContext initContext)
    </p>
    <p>
      Реализовывать логику внутри метода init <b>запрещенно</b>. Внутри метода
      init разрешается обращаться только к методам modulesManager и initContext,
      при чем при статической загрузке модуля initContext = null, а при
      динамической загрузке модуля через команду loadModule он будет содержать
      инстанс контекста, из которого можно получить доступ к LaunchServer
    </p>
    <h3>События(евенты)</h3>
    <p>
      Всё что можно сделать из init - загружать другие модули, получать их
      инстансы и, самое важное, <b>подписаться на события</b>. Это единственный
      правильный способ реализовывать логику. Событий может быть великое
      множество, вы так же можете создавать свои евенты и позволять другим
      модулям реагировать на события вашего модуля.
    </p>
    <p>Встроеные общие события находятся в pro.gravit.launcher.modules.event</p>
    <p>
      События лаунчсервера находятся в pro.gravit.launchserver.modules.events.
      Именно их вы должны использовать при работе с лаунчсервером, так как
      внутри этих евентов вы получаете инстанс LaunchServer, центральный инстанс
      всего лаунчсервера, откуда можно добраться до всего
    </p>
    <p>
      События лаунчера находятся в pro.gravit.launcher.client.events. Именно их
      вы должны использовать при работе с лаунчером, так как они содержат
      основные объекты. В отличии от лаунчсервера тут нет как такового
      "центрального" объекта. Большинство функций статические и получение
      объекта для их использования не требуется. При этом если вы хотите
      работать с GUI на 5.1.0+ то вам необходимо еще учесть события модуля Java
      рантайма
    </p>
    <p>
      Для подписки на событие вы должны создать метод в вашем классе,
      принимающий 1 аргумент соответствующий типу евента что вы хотите
      обрабатывать, после чего в init вы должны вызвать registerEvent, первый
      аргумент - ваш метод-обработчик, второй аргумент - класс интересующего вас
      евента
    </p>
    <p>
      Обратите внимание при загрузке модуля через loadModule евенты, которые уже
      прошли не вызываются, вместо этого вам передается initContext
    </p>
    <h3>Общие возможности API</h3>
    <p>
      Хелперы - классы помощники, упростят вам рутиные задачи. Они находятся в
      pro.gravit.utils.helper и
      <b>доступны извне при включенном proguard</b>(тоесть вы можете ими
      пользоваться в майнкрафт клиенте, модах)
    </p>
    <p>
      Сериализация абстрактных классов или интерфейсов(AuthProvider/AuthHandler
      и всё что имеет type в сериализованном виде) выполняется с помощью
      pro.gravit.utils.ProviderMap и pro.gravit.utils.UniversalJsonAdapter
      <b>доступны извне при включенном proguard</b>
    </p>
    <p>
      Запросы к лаунчсерверу. Находятся в pro.gravit.launcher.request(ответы в
      pro.gravit.launcher.events) и
      <b>доступны извне при включенном proguard</b>. Блокирующий(синхронный)
      запрос выполняется с помощью создания инстанса нужного Request и
      выполнения метода request(). Этот метод блокирует поток до того как ответ
      не придет, а следовательно может серьезно затормозить работу при
      непраивльном проектировании. Используйте эту возможность с
      осторожностью<br />Неблокирующий(асинхронный) заключается в использовании
      метода request класса StdWebSocketService(5.1.0+), который возвращает не
      результат, а CompletableFuture, на который вы должны повесить обработку
      успешного завершения запроса и ошибки(см документацию по
      CompletableFuture, там очень много всего интересного). Позволяет дождаться
      завершения нескольких запросов, одного из, проводить любые манипуляции и
      логику. Для ветки 5.0.X этот код придется реализовывать самостоятельно(см
      AsyncEventHandler в ранних версиях JavaRuntime) Этот метод рекомендуется к
      использованию
    </p>
    <p>
      Подсистема команд. Довольно обширная и интересная система, находится в
      pro.gravit.utils.command. Поддерживается разделение команд на категории,
      добавление, удаление команды и замена своей реализацией. Поддерживается
      автокомплит, подкоманды. Некоторое представление о возможностях этой
      системы можно получить изучив тесты в LauncherCore
    </p>
    <p>
      Хеширование директорий, Diff'ы. Находятся в pro.gravit.launcher.hasher и
      главная их задача - определять разницу между двумя
      директориями(недостающие/измененные и лишние файлы). На них построена
      система обновления
    </p>
    <p>
      Скачивание списка файлов в несколько потоков.
      pro.gravit.launcher.AsyncDownloader позволяет скачать список файлов по
      http в несколько потоков наиболее оптимальным способом с максимальной
      скоростью
    </p>
    <h3>Основные API лаунчсервера</h3>
    <p>
      Ответы на запросы. Находятся в pro.gravit.launchserver.socket.response и
      определяют всю логику ответа на какой либо запрос. Вы можете
      зарегистрировать свой Response вызвав WebSocketService.providers.register
      . Для отправки ошибки используется sendError(если ваш Response наследуется
      от SimpleResponse(рекомендуется)), для отправки результата sendObject. Для
      получения параметров просто создаете поле нужного типа в вашем Response,
      сериализация gson сделает свое дело и в момент выполнения все эти поля
      будут содержать данные полученные из json запроса клиента. Обратите
      внимание на параметр requestUUID, он используется для определения на какой
      запрос поступил данный ответ. При наследовании SimpleResponse и
      использовании sendObject/sendError класс SimpleResponse позаботится об
      этом за вас. В противном случае будьте внимательны и если что то
      происходит непонятное откройте wireshark
    </p>
    <p>
      Работа с подключенными клиентами. События. События можно отправлять и без
      запроса, для чего необходимо воспользоваться методами
      WebSocketService(launchserver.nettyServerSocketHandler.nettyServer.service),
      тут есть методы как для отправки события конкретному клиенту, так и всем
      подключенным клиентам. Если вам необходимо отправить события выборочно,
      просмотреть список клиентов или что то подобное - обратитесь к коду
      pro.gravit.launchserver.command.service.ClientsCommand(получение
      WebSocketFrameHandler из netty pipeline и оттуда уже доставать
      информацию). Некоторые ответы на запросы(то что называется RequestEvent)
      могут быть посланы без запроса, для чего в requestUUID необходимо записать
      "UUID события", который находится в RequestEvent.eventUUID. Это позволяет
      например удаленно авторизировать клиента, который не посылал запрос(пример
      из модуля UnsafeCommandPack)
    </p>
    <p>
      Сборка лаунчера. pipeline. Сборка лаунчера осуществляется на основе
      pipeline(pro.gravit.launchserver.binary). Pipeline - это последовательный
      список задач, на вход задаче подают путь к входному файлу, а на выход
      ожидается путь к выходному файлу. Выходной файла первой задачи является
      взодным файлом последующей задачи. Это позволяет преобразовывать JAR по
      своему усмотрению, добавив свой Task в нужное место pipeline. Так же с
      5.1.0(?) поддерживается pipeline для EXE файлов.
    </p>
    <p>
      AuthProvider/AuthHandler/HWIDHandler/TextureProvider всё это можно
      реализовать самостоятельно, создав класс, отнаследовавшись от
      Handelr/Provider функционал которого вы хотите реализовать и
      зарегистрировав свой класс в ProviderMap соответствующего
      Handler/Provider.
    </p>
    <p>
      Компоненты. Компоненты - очень удобный способ конфигурировать ваш код.
      Помимо конфигурирования через modulesConfigManager/JsonSerializable вы
      можете просто создать компонент и зарегистрировтаь его, в таком случае ваш
      модуль будет конфигурироваться прямо из основного конфига, а вы получите
      удобные средства для реализации ваших идей. Код компонентов и их
      реализация находится в pro.gravit.launchserver.components
    </p>
    <p>
      Reconfigurable - это интерфейс создания команд для вашего Handler/Provider
      или компонента. Работает он на механизме подкоманд, для вызова команд
      Reconfigurable используется команда config (имя компонента) (команда
      компонента) (аргументы), поддерживается автокомплит. Вам необходимо всего
      лишь отнаследоваться от интерфейса Reconfigurable и реализовать метод
      getCommands, где прописать все ваши команды. Если у вас Provider/Handler
      или компонент команды зарегистрируются автоматически, если же этого не
      происходит вызовите launchserver.registerObject
    </p>
    <p v-if="version >= 50109">
      WebAPI/Severlet - это механизм обработки http запросов лаунчсервером. Он
      предлязначен для небольших REST приложений, не требующих шаблонизацию или
      прямого взаимодействия с пользователем. Для регистрации своего северлета
      используется метод
      <codes
        >NettyWebAPIHandler.addNewSeverlet(String path, SimpleSeverletHandler
        callback)</codes
      ><br />
      После регистрации ваш северлет будет доступен извне по адресу
      <codes>http(s)://yourdomain(:9274)/webapi/(path)</codes>.
      <span v-if="version >= 50200"
        >Вы можете использовать стандартные методы
        <codes>getParamsFromUri</codes>,
        <codes>simpleResponse/simpleJsonResponse</codes>,
        <codes>sendHttpResponse</codes> для упрощения парсинга параметров и
        отправки ответов</span
      >
    </p>
    <h3>Основные API лаунчера</h3>
    <p>
      Лаунчер предоставляет внешние сервисы API в
      <codes>pro.gravit.launcher.api</codes>, которые доступны извне при
      включенном proguard
    </p>
    <p>
      <b>LauncherInject</b> используется для вставки параметров при сборке с
      помощью ASM. Для получения параметра вы должны на соответствующий элемент
      постаивть аннотацию <codes>@LauncherInject(value="path.to.value")</codes
      ><br />
      Стандартные параметры начинаются с <codes>launchercore</codes> или
      <codes>launcher</codes>, а параметры конфигурации модуля лаунчера
      формируются по шаблону
      <codes
        >modules.название_конфига_модуля_в_lowercase.название_поля_в_lowercase</codes
      >
    </p>
    <p>
      Для получения возможности конфигурировать модуль из лаунчсервера вы
      должны:
    </p>
    <ol>
      <li>
        Создать класс конфига с статическим методом
        <codes>public static Object getDefault()</codes>, возвращающий конфиг по
        умолчанию
      </li>
      <li>
        Добавить одно или несколько полей, помеченных аннотацией
        <codes
          >@LauncherInject(value="modules.название_конфига_модуля_в_lowercase.название_поля_в_lowercase")</codes
        >
      </li>
      <li>
        Добавить в манифест помимо Module-Main-Class поля Module-Config-Name(как
        правило совпадает с названием модуля) и Module-Config-Class(класс
        конфигурации модуля)
      </li>
      <li>
        <b>Ограничения:</b> Конфиг модуля не может содержать нестандартных
        классов или дополнительной вложенности. Поддерживаются: int, short,
        byte, byte[], long, String, List, Map.
      </li>
    </ol>
    <h3 v-if="version >= 50200">Отладка лаунчера</h3>
    <p v-if="version >= 50200">
      Для запуска лаунчера в тестовом режиме вы должны указать mainClass
      <codes>pro.gravit.launcher.debug.DebugMain</codes>
    </p>
    <ul v-if="version >= 50200">
      <li>
        <codes>-Dlauncherdebug.websocket=ws://localhost:9274/api</codes> -
        подключение WebSocket
      </li>
      <li>
        <codes>-Dlauncherdebug.projectname=Minecraft</codes> - указание
        projectName
      </li>
      <li>
        <codes>-Dlauncherdebug.modules=a.b.c,a.b.d</codes> - список классов
        модулей, разделенных запятыми
      </li>
      <li>
        <codes>-Dlauncherdebug.modulefiles=module1.jar,module2.jar</codes> -
        список файлов модулей, разделенных запятыми
      </li>
      <li>Запуск с помощью Gradle: <codes>./gradlew runDev</codes></li>
    </ul>
    <p v-if="version >= 50200">
      Для отладки рантайма из IDEA укажите следующие параметры:
    </p>
    <ul v-if="version >= 50200">
      <li>Модуль: JavaRuntime.main</li>
      <li>
        Аргументы jvm:
        -Dlauncherdebug.modules=pro.gravit.launcher.client.JavaRuntimeModule
        (если параметр не отображаются нажмите Modify Options -> Add VM options)
      </li>
      <li>Main Class: pro.gravit.launcher.debug.DebugMain</li>
    </ul>
    <p v-if="version >= 50200">Ограничения отладочного режима:</p>
    <ul v-if="version >= 50200">
      <li>
        Не будет работать опция "Сохранить пароль", так как ключ шифрования
        пароля зашивается лаунчсервером
      </li>
      <li>
        Невозможно запустить клиент майнкрафта(при этом все этапы скачивания,
        проверки, и подготовки к старту работать будут)
      </li>
      <li>
        Лаунчер не будет пытаться обновиться и получить список методов
        авторизации
      </li>
      <li>
        Может не работать проверка HWID, так как лаунчсервер не будет доверять
        лаунчеру
      </li>
      <li>
        Отладочный режим невозможно активировать на собранном лаунчере(командой
        build лаунчсервера)
      </li>
    </ul>
  </div>
</template>
<script>
import coremethods from "@/components/core-methods.js";
export default {
  mixins: [coremethods],
  created: function() {}
};
</script>
